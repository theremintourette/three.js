<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - light probe</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - light probe
		</div>

		<script type="module">

			import * as THREE from '../src/Three.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';

			import { OrbitControls } from './jsm/controls/OrbitControls.js';

			import { FBXLoader } from './jsm/loaders/FBXLoader.js';

			import { HDRCubeTextureLoader } from './jsm/loaders/HDRCubeTextureLoader.js';

			var mesh, renderer, scene, camera;

			var gui;

			var directionalLight;
			var particleLight;

			// linear color space
			var API = {
				directionalLightIntensity: 0,
				particleLightIntensity: 0.5,
				envMapIntensity: 1.0,
				color: new THREE.Color( 1, 1, 1 ),
				sheen: new THREE.Color( 1, 1, 1 ),
				subsurface: new THREE.Color( 1, 1, 1 ),
				roughness: 1.0,
			};

			init();

			function init() {

				// model
				new FBXLoader().load( 'models/fbx/cloth.fbx', function ( loadedModel ) {

					mesh = loadedModel.children[ 0 ];

					// renderer
					renderer = new THREE.WebGLRenderer( { antialias: true } );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );
					document.body.appendChild( renderer.domElement );

					// tone mapping
					renderer.toneMapping = THREE.NoToneMapping;

					renderer.outputEncoding = THREE.sRGBEncoding;

					var pmremGenerator = new THREE.PMREMGenerator( renderer );
					pmremGenerator.compileEquirectangularShader();

					// scene
					scene = new THREE.Scene();

					// camera
					camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
					camera.position.set( 0, 25, 25 );

					// controls
					var controls = new OrbitControls( camera, renderer.domElement );
					controls.addEventListener( 'change', render );
					controls.minDistance = 10;
					controls.maxDistance = 50;

					// light
					directionalLight = new THREE.DirectionalLight( 0xffffff, API.directionalLightIntensity );
					directionalLight.position.set( 10, 10, 10 );
					scene.add( directionalLight );

					// particle light
					particleLight = new THREE.Mesh(
						new THREE.SphereBufferGeometry( 4, 8, 8 ),
						new THREE.MeshBasicMaterial( { color: 0xffffff } )
					);
					scene.add( particleLight );
					particleLight.add( new THREE.PointLight( 0xffffff, 0.5 ) );

					new HDRCubeTextureLoader()
						.setDataType( THREE.UnsignedByteType )
						.setPath( 'textures/cube/pisaHDR/' )
						.load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
							function ( hdrCubeMap ) {

								var hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );
								hdrCubeMap.dispose();
								pmremGenerator.dispose();

								scene.background = hdrCubeRenderTarget.texture;
								scene.environment = hdrCubeRenderTarget.texture;

								mesh.material = new THREE.MeshClothMaterial( {
									color: API.color,
									sheen: API.sheen,
									subsurface: API.subsurface,
									roughness: API.roughness,
									envMapIntensity: API.envMapIntensity,
									side: THREE.DoubleSide,
								} );

								// mesh
								scene.add( mesh );
								// gui
								gui = new GUI();

								gui.width = 300;

								gui.domElement.style.userSelect = 'none';

								var fl = gui.addFolder();

								fl.add( API, 'envMapIntensity', 0, 1, 0.02 )
									.name( 'Envmap Intensity' )
									.onChange( function () {

										mesh.material.envMapIntensity = API.envMapIntensity;

									} );

								fl.add( API, 'particleLightIntensity', 0, 1, 0.02 )
									.name( 'Point Light' )
									.onChange( function () {

										particleLight.children[ 0 ].intensity = API.particleLightIntensity;

									} );

								fl.add( API, 'directionalLightIntensity', 0, 1, 0.02 )
									.name( 'Directional Light' )
									.onChange( function () {

										directionalLight.intensity = API.directionalLightIntensity;

									} );

								fl.add( API, 'roughness', 0, 1, 0.02 )
									.name( 'Roughness' )
									.onChange( function () {

										mesh.material.roughness = API.roughness;

									} );

								fl.addColor( API, 'color' )
									.name( 'Color' )
									.setValue( { r: 255, g: 255, b: 255 } )
									.onChange( () => {

										mesh.material.color.set( new THREE.Color( API.color.r / 255, API.color.g / 255, API.color.b / 255 ) );

									} );
								fl.addColor( API, 'sheen' )
									.name( 'Sheen' )
									.setValue( { r: 255, g: 255, b: 255 } )

									.onChange( () => {

										mesh.material.sheen.set( new THREE.Color( API.sheen.r / 255, API.sheen.g / 255, API.sheen.b / 255 ) );

									} );
								fl.addColor( API, 'subsurface' )
									.name( 'Subsurface' )
									.setValue( { r: 255, g: 255, b: 255 } )
									.onChange( () => {

										mesh.material.subsurface.set( new THREE.Color( API.subsurface.r / 255, API.subsurface.g / 255, API.subsurface.b / 255 ) );

									} );

								fl.open();

								animate();
			
							}

						);
			
	} );

				// listener
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function animate() {

				var timer = Date.now() * 0.00025;

				particleLight.position.x = Math.sin( timer * 7 ) * 300;
				particleLight.position.y = Math.cos( timer * 5 ) * 400;
				particleLight.position.z = Math.cos( timer * 3 ) * 300;

				requestAnimationFrame( animate );
				render();

			}

			function onWindowResize() {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
